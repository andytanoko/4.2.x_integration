// %1023962281098:com.gridnode.pdip.app.deployment.bpss%
/**
 * This software is the proprietary information of GridNode Pte Ltd.
 * Use is subjected to license terms.
 *
 * Copyright 2001-2002 (C) GridNode Pte Ltd. All Rights Reserved.
 *
 * File: 
 *
 ****************************************************************************
 * Date           Author              Changes
 ****************************************************************************
 * Jun 10 2002   Mathew	        Created
 * Jun 13 2002   Mathew         Repackaged
 * Dec 08 2005   Tam Wei Xiang  i)   To remove the depedency on borland xml API.
 *                                   Use GN XML api instead.
 *                              ii)  Change method marshal(), unmarshal(element) to
 *                                   buildElement() and buildModel(element).
 *                              iii) We will use the getParent and setParent method
 *                                   in AbstractBpssModel instead of using XMLObject._getParent
 *                                   and _setParent
 *                              iv)  method validate(boolean) has been removed.     
 */



/**
 * This file is generated by BorlandXML.
 */
package com.gridnode.pdip.app.deploy.manager.bpss;

import java.util.*;

import com.gridnode.pdip.app.deploy.manager.IGWFDeployable;
import com.gridnode.pdip.framework.exceptions.domain.GWFException;
import com.gridnode.xml.adapters.GNAttribute;
import com.gridnode.xml.adapters.GNElement;
import com.gridnode.xml.adapters.GNXMLDocumentUtility;

/**
 * The Package class represents the element "Package" with the content
 * model defined as follows:
 * <p>
 * &lt;!ELEMENT Package (Documentation*,(Package|BinaryCollaboration|BusinessTransaction|MultiPartyCollaboration)*)&gt;<br>
 */
public class Package
  extends AbstractBpssModel
  implements IGWFDeployable
{

  /**
	 * Serial Version UID
	 */
	private static final long serialVersionUID = -6371303886702506444L;

	/** xml tag name of this element. */
  public static String _tagName = "Package";
  
  /** Defines a name attribute */
  public GNAttribute name = GNXMLDocumentUtility.newAttribute("name", "");
  
  /** Defines a nameID attribute */
  public GNAttribute nameID = GNXMLDocumentUtility.newAttribute("nameID", "");
  
  
  /** Defines a list of Documentation objects. */
  protected ArrayList _objDocumentation = new ArrayList();

  /** Defines a list of Package objects. */
  protected ArrayList _objPackage = new ArrayList();

  /** Defines a list of BinaryCollaboration objects. */
  protected ArrayList _objBinaryCollaboration = new ArrayList();

  /** Defines a list of BusinessTransaction objects. */
  protected ArrayList _objBusinessTransaction = new ArrayList();

  /** Defines a list of MultiPartyCollaboration objects. */
  protected ArrayList _objMultiPartyCollaboration = new ArrayList();

  /**
     * Creates an empty Package object
     */
  public Package()
  {
    super();
  }

  /**
     * Gets the value of "name" attribute.
     */
  public String getName()
  {
    return name.getValue();
  }

  /**
     * Replaces the existing attribute value with a new value.
     * @param value    New value.
     */
  public void setName(String value_)
  {
    name.setValue(value_);
  }

  /**
     * Gets the value of "nameID" attribute.
     */
  public String getNameID()
  {
    return nameID.getValue();
  }

  /**
     * Replaces the existing attribute value with a new value.
     * @param value    New value.
     */
  public void setNameID(String value_)
  {
    nameID.setValue(value_);
  }

  /**
     * Returns an array of Documentation objects. The length of the returned
     * array is zero if the list of Documentation object is empty.
     */
  public Documentation[] getDocumentation()
  {
    return (Documentation[])_objDocumentation.toArray(new Documentation[0]);
  }

  /**
     * Replaces all existing Documentation objects with a new array of
     * Documentation objects.
     * @param objArray    an array of Documentation objects.
     */
  public void setDocumentation(Documentation[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objDocumentation.clear();
    else
    {
      this._objDocumentation = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
        if (objArray[i] != null)
          objArray[i].setParent(this);
      }
    }
  }

  /**
     * Gets the Documentation object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public Documentation getDocumentation(int index)
  {
    return (Documentation)_objDocumentation.get(index);
  }

  /**
     * Replaces an existing Documentation object at the specified index with
     * a new Documentation object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setDocumentation(int index, Documentation obj)
  {
    if (obj == null)
      removeDocumentation(index);
    else
    {
      _objDocumentation.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of Documentation objects in the list.
     */
  public int getDocumentationCount()
  {
    return _objDocumentation.size();
  }

  /**
     * Returns <code>true</code> if there is no Documentation object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoDocumentation()
  {
    return _objDocumentation.size() == 0;
  }

  /**
     * Returns a read-only list of Documentation objects.
     */
  public List getDocumentationList()
  {
    return Collections.unmodifiableList(_objDocumentation);
  }

  /**
     * Adds a new Documentation object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addDocumentation(Documentation obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objDocumentation.add(obj);
  }

  /**
     * Adds a list of new Documentation objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addDocumentation(Collection coDocumentation)
  {
    if (coDocumentation == null)
      return false;
    java.util.Iterator it = coDocumentation.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
    }
    return _objDocumentation.addAll(coDocumentation);
  }

  /**
     * Removes an existing Documentation object at the specified index.
     * @return    The removed object.
     */
  public Documentation removeDocumentation(int index)
  {
    return (Documentation)_objDocumentation.remove(index);
  }

  /**
     * Removes the specified Documentation object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeDocumentation(Documentation obj)
  {
    return _objDocumentation.remove(obj);
  }

  /**
     * Clears all Documentation objects from the list.
     */
  public void clearDocumentationList()
  {
    _objDocumentation.clear();
  }

  /**
     * Returns an array of Package objects. The length of the returned
     * array is zero if the list of Package object is empty.
     */
  public Package[] getPackage()
  {
    return (Package[])_objPackage.toArray(new Package[0]);
  }

  /**
     * Replaces all existing Package objects with a new array of
     * Package objects.
     * @param objArray    an array of Package objects.
     */
  public void setPackage(Package[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objPackage.clear();
    else
    {
      this._objPackage = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
        if (objArray[i] != null)
          objArray[i].setParent(this);
      }
    }
  }

  /**
     * Gets the Package object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public Package getPackage(int index)
  {
    return (Package)_objPackage.get(index);
  }

  /**
     * Replaces an existing Package object at the specified index with
     * a new Package object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setPackage(int index, Package obj)
  {
    if (obj == null)
      removePackage(index);
    else
    {
      _objPackage.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of Package objects in the list.
     */
  public int getPackageCount()
  {
    return _objPackage.size();
  }

  /**
     * Returns <code>true</code> if there is no Package object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoPackage()
  {
    return _objPackage.size() == 0;
  }

  /**
     * Returns a read-only list of Package objects.
     */
  public List getPackageList()
  {
    return Collections.unmodifiableList(_objPackage);
  }

  /**
     * Adds a new Package object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addPackage(Package obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objPackage.add(obj);
  }

  /**
     * Adds a list of new Package objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addPackage(Collection coPackage)
  {
    if (coPackage == null)
      return false;
    java.util.Iterator it = coPackage.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
    }
    return _objPackage.addAll(coPackage);
  }

  /**
     * Removes an existing Package object at the specified index.
     * @return    The removed object.
     */
  public Package removePackage(int index)
  {
    return (Package)_objPackage.remove(index);
  }

  /**
     * Removes the specified Package object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removePackage(Package obj)
  {
    return _objPackage.remove(obj);
  }

  /**
     * Clears all Package objects from the list.
     */
  public void clearPackageList()
  {
    _objPackage.clear();
  }

  /**
     * Returns an array of BinaryCollaboration objects. The length of the returned
     * array is zero if the list of BinaryCollaboration object is empty.
     */
  public BinaryCollaboration[] getBinaryCollaboration()
  {
    return (BinaryCollaboration[])_objBinaryCollaboration.toArray(
                 new BinaryCollaboration[0]);
  }

  /**
     * Replaces all existing BinaryCollaboration objects with a new array of
     * BinaryCollaboration objects.
     * @param objArray    an array of BinaryCollaboration objects.
     */
  public void setBinaryCollaboration(BinaryCollaboration[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objBinaryCollaboration.clear();
    else
    {
      this._objBinaryCollaboration = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
        if (objArray[i] != null)
          objArray[i].setParent(this);
      }
    }
  }

  /**
     * Gets the BinaryCollaboration object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public BinaryCollaboration getBinaryCollaboration(int index)
  {
    return (BinaryCollaboration)_objBinaryCollaboration.get(index);
  }

  /**
     * Replaces an existing BinaryCollaboration object at the specified index with
     * a new BinaryCollaboration object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setBinaryCollaboration(int index, BinaryCollaboration obj)
  {
    if (obj == null)
      removeBinaryCollaboration(index);
    else
    {
      _objBinaryCollaboration.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of BinaryCollaboration objects in the list.
     */
  public int getBinaryCollaborationCount()
  {
    return _objBinaryCollaboration.size();
  }

  /**
     * Returns <code>true</code> if there is no BinaryCollaboration object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoBinaryCollaboration()
  {
    return _objBinaryCollaboration.size() == 0;
  }

  /**
     * Returns a read-only list of BinaryCollaboration objects.
     */
  public List getBinaryCollaborationList()
  {
    return Collections.unmodifiableList(_objBinaryCollaboration);
  }

  /**
     * Adds a new BinaryCollaboration object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addBinaryCollaboration(BinaryCollaboration obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objBinaryCollaboration.add(obj);
  }

  /**
     * Adds a list of new BinaryCollaboration objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addBinaryCollaboration(Collection coBinaryCollaboration)
  {
    if (coBinaryCollaboration == null)
      return false;
    java.util.Iterator it = coBinaryCollaboration.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
    }
    return _objBinaryCollaboration.addAll(coBinaryCollaboration);
  }

  /**
     * Removes an existing BinaryCollaboration object at the specified index.
     * @return    The removed object.
     */
  public BinaryCollaboration removeBinaryCollaboration(int index)
  {
    return (BinaryCollaboration)_objBinaryCollaboration.remove(index);
  }

  /**
     * Removes the specified BinaryCollaboration object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeBinaryCollaboration(BinaryCollaboration obj)
  {
    return _objBinaryCollaboration.remove(obj);
  }

  /**
     * Clears all BinaryCollaboration objects from the list.
     */
  public void clearBinaryCollaborationList()
  {
    _objBinaryCollaboration.clear();
  }

  /**
     * Returns an array of BusinessTransaction objects. The length of the returned
     * array is zero if the list of BusinessTransaction object is empty.
     */
  public BusinessTransaction[] getBusinessTransaction()
  {
    return (BusinessTransaction[])_objBusinessTransaction.toArray(
                 new BusinessTransaction[0]);
  }

  /**
     * Replaces all existing BusinessTransaction objects with a new array of
     * BusinessTransaction objects.
     * @param objArray    an array of BusinessTransaction objects.
     */
  public void setBusinessTransaction(BusinessTransaction[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objBusinessTransaction.clear();
    else
    {
      this._objBusinessTransaction = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
        if (objArray[i] != null)
          objArray[i].setParent(this);
      }
    }
  }

  /**
     * Gets the BusinessTransaction object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public BusinessTransaction getBusinessTransaction(int index)
  {
    return (BusinessTransaction)_objBusinessTransaction.get(index);
  }

  /**
     * Replaces an existing BusinessTransaction object at the specified index with
     * a new BusinessTransaction object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setBusinessTransaction(int index, BusinessTransaction obj)
  {
    if (obj == null)
      removeBusinessTransaction(index);
    else
    {
      _objBusinessTransaction.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of BusinessTransaction objects in the list.
     */
  public int getBusinessTransactionCount()
  {
    return _objBusinessTransaction.size();
  }

  /**
     * Returns <code>true</code> if there is no BusinessTransaction object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoBusinessTransaction()
  {
    return _objBusinessTransaction.size() == 0;
  }

  /**
     * Returns a read-only list of BusinessTransaction objects.
     */
  public List getBusinessTransactionList()
  {
    return Collections.unmodifiableList(_objBusinessTransaction);
  }

  /**
     * Adds a new BusinessTransaction object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addBusinessTransaction(BusinessTransaction obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objBusinessTransaction.add(obj);
  }

  /**
     * Adds a list of new BusinessTransaction objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addBusinessTransaction(Collection coBusinessTransaction)
  {
    if (coBusinessTransaction == null)
      return false;
    java.util.Iterator it = coBusinessTransaction.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
    }
    return _objBusinessTransaction.addAll(coBusinessTransaction);
  }

  /**
     * Removes an existing BusinessTransaction object at the specified index.
     * @return    The removed object.
     */
  public BusinessTransaction removeBusinessTransaction(int index)
  {
    return (BusinessTransaction)_objBusinessTransaction.remove(index);
  }

  /**
     * Removes the specified BusinessTransaction object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeBusinessTransaction(BusinessTransaction obj)
  {
    return _objBusinessTransaction.remove(obj);
  }

  /**
     * Clears all BusinessTransaction objects from the list.
     */
  public void clearBusinessTransactionList()
  {
    _objBusinessTransaction.clear();
  }

  /**
     * Returns an array of MultiPartyCollaboration objects. The length of the returned
     * array is zero if the list of MultiPartyCollaboration object is empty.
     */
  public MultiPartyCollaboration[] getMultiPartyCollaboration()
  {
    return (MultiPartyCollaboration[])_objMultiPartyCollaboration.toArray(
                 new MultiPartyCollaboration[0]);
  }

  /**
     * Replaces all existing MultiPartyCollaboration objects with a new array of
     * MultiPartyCollaboration objects.
     * @param objArray    an array of MultiPartyCollaboration objects.
     */
  public void setMultiPartyCollaboration(MultiPartyCollaboration[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objMultiPartyCollaboration.clear();
    else
    {
      this._objMultiPartyCollaboration = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
        if (objArray[i] != null)
          objArray[i].setParent(this);
      }
    }
  }

  /**
     * Gets the MultiPartyCollaboration object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public MultiPartyCollaboration getMultiPartyCollaboration(int index)
  {
    return (MultiPartyCollaboration)_objMultiPartyCollaboration.get(index);
  }

  /**
     * Replaces an existing MultiPartyCollaboration object at the specified index with
     * a new MultiPartyCollaboration object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setMultiPartyCollaboration(int index, 
                                         MultiPartyCollaboration obj)
  {
    if (obj == null)
      removeMultiPartyCollaboration(index);
    else
    {
      _objMultiPartyCollaboration.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of MultiPartyCollaboration objects in the list.
     */
  public int getMultiPartyCollaborationCount()
  {
    return _objMultiPartyCollaboration.size();
  }

  /**
     * Returns <code>true</code> if there is no MultiPartyCollaboration object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoMultiPartyCollaboration()
  {
    return _objMultiPartyCollaboration.size() == 0;
  }

  /**
     * Returns a read-only list of MultiPartyCollaboration objects.
     */
  public List getMultiPartyCollaborationList()
  {
    return Collections.unmodifiableList(_objMultiPartyCollaboration);
  }

  /**
     * Adds a new MultiPartyCollaboration object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addMultiPartyCollaboration(MultiPartyCollaboration obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objMultiPartyCollaboration.add(obj);
  }

  /**
     * Adds a list of new MultiPartyCollaboration objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addMultiPartyCollaboration(Collection coMultiPartyCollaboration)
  {
    if (coMultiPartyCollaboration == null)
      return false;
    java.util.Iterator it = coMultiPartyCollaboration.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
    }
    return _objMultiPartyCollaboration.addAll(coMultiPartyCollaboration);
  }

  /**
     * Removes an existing MultiPartyCollaboration object at the specified index.
     * @return    The removed object.
     */
  public MultiPartyCollaboration removeMultiPartyCollaboration(int index)
  {
    return (MultiPartyCollaboration)_objMultiPartyCollaboration.remove(index);
  }

  /**
     * Removes the specified MultiPartyCollaboration object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeMultiPartyCollaboration(MultiPartyCollaboration obj)
  {
    return _objMultiPartyCollaboration.remove(obj);
  }

  /**
     * Clears all MultiPartyCollaboration objects from the list.
     */
  public void clearMultiPartyCollaborationList()
  {
    _objMultiPartyCollaboration.clear();
  }


  /**
     * Returns a list containing all child elements. Each element in the list is a subclass
     * of XmlObject.
     */
  public java.util.List _getChildren()
  {
    java.util.List children = new java.util.ArrayList();

    /** adds _objDocumentation */
    if (_objDocumentation != null && _objDocumentation.size() > 0)
      children.add(_objDocumentation);

    /** adds _objPackage */
    if (_objPackage != null && _objPackage.size() > 0)
      children.add(_objPackage);

    /** adds _objBinaryCollaboration */
    if (_objBinaryCollaboration != null && 
        _objBinaryCollaboration.size() > 0)
      children.add(_objBinaryCollaboration);

    /** adds _objBusinessTransaction */
    if (_objBusinessTransaction != null && 
        _objBusinessTransaction.size() > 0)
      children.add(_objBusinessTransaction);

    /** adds _objMultiPartyCollaboration */
    if (_objMultiPartyCollaboration != null && 
        _objMultiPartyCollaboration.size() > 0)
      children.add(_objMultiPartyCollaboration);
    return children;
  }

  /**
     * Gets the tag name of this element.
     */
  public String get_TagName()
  {
    return _tagName;
  }

  /**
   * DOCUMENT ME!
   * 
   * @param specUId DOCUMENT ME!
   * @param incomplete DOCUMENT ME!
   * @return DOCUMENT ME! 
   * @throws GWFException DOCUMENT ME!
   */
  public int deploy(long specUId, Hashtable incomplete)
             throws GWFException
  {
    return 1;
  }

  /**
   * DOCUMENT ME!
   * 
   * @param specUId DOCUMENT ME!
   * @param parentEntryUId DOCUMENT ME!
   * @throws GWFException DOCUMENT ME!
   */
  public void setParentEntryUId(long specUId, long parentEntryUId)
                         throws GWFException
  {
  }
  
  /**
   * Unmarshals the specified "Package" element back to a Package object.
   */
  public Package buildModel(GNElement elem)
  {
  	if (elem == null)
      return null;

      /** Unmarshals "name" attribute */
  	  super.setAttributeValue(name,elem.getAttribute("name") );

      /** Unmarshals "nameID" attribute */
  	  super.setAttributeValue(nameID, elem.getAttribute("nameID"));

    /** Unmarshals a list of "<<_tagName_>>" elements back to Documentation objects. */
    Iterator it1 = elem.getChildren(Documentation._tagName).iterator();
    while (it1.hasNext())
    {
    	Documentation doc = new Documentation();
      addDocumentation(doc.buildModel(
                                        (GNElement)it1.next()));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to Package objects. */
    Iterator it2 = elem.getChildren(Package._tagName).iterator();
    while (it2.hasNext())
    {
    	Package pack = new Package();
      addPackage(pack.buildModel(
                                  (GNElement)it2.next()));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to BinaryCollaboration objects. */
    Iterator it3 = elem.getChildren(BinaryCollaboration._tagName).iterator();
    while (it3.hasNext())
    {
    	BinaryCollaboration binColl = new BinaryCollaboration();
      addBinaryCollaboration(binColl.buildModel(
                                              (GNElement)it3.next()));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to BusinessTransaction objects. */
    Iterator it4 = elem.getChildren(BusinessTransaction._tagName).iterator();
    while (it4.hasNext())
    {
    	BusinessTransaction bzTrans = new BusinessTransaction();
      addBusinessTransaction(bzTrans.buildModel(
                                              (GNElement)it4.next()));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to MultiPartyCollaboration objects. */
    Iterator it5 = elem.getChildren(MultiPartyCollaboration._tagName).iterator();
    while (it5.hasNext())
    {
    	MultiPartyCollaboration multiPC = new  MultiPartyCollaboration();
      addMultiPartyCollaboration(multiPC.buildModel(
                                                  (GNElement)it5.next()));
    }
    return this;
  }
  
  /**
   * Marshals this object to an element.
   */
  public GNElement buildElement()
  {
  	GNElement elem = GNXMLDocumentUtility.newElement(get_TagName());

    /** Marshals "name" attribute */
  	addAttributeToElement(elem, this._ATTR_DEFAULT_REQUIRED, name);

    /** Marshals "nameID" attribute */
  	addAttributeToElement(elem, this._ATTR_DEFAULT_IMPLIED, nameID);

    /** Marshals a list of Documentation objects to elements */
    Iterator it1 = _objDocumentation.iterator();
    while (it1.hasNext())
    {
      Documentation obj = (Documentation)it1.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of Package objects to elements */
    Iterator it2 = _objPackage.iterator();
    while (it2.hasNext())
    {
      Package obj = (Package)it2.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of BinaryCollaboration objects to elements */
    Iterator it3 = _objBinaryCollaboration.iterator();
    while (it3.hasNext())
    {
      BinaryCollaboration obj = (BinaryCollaboration)it3.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of BusinessTransaction objects to elements */
    Iterator it4 = _objBusinessTransaction.iterator();
    while (it4.hasNext())
    {
      BusinessTransaction obj = (BusinessTransaction)it4.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of MultiPartyCollaboration objects to elements */
    Iterator it5 = _objMultiPartyCollaboration.iterator();
    while (it5.hasNext())
    {
      MultiPartyCollaboration obj = (MultiPartyCollaboration)it5.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }
    return elem;
  }
}