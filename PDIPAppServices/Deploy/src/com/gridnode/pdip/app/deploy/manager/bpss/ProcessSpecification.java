// %1023962281582:com.gridnode.pdip.app.deployment.bpss%
/**
 * This software is the proprietary information of GridNode Pte Ltd.
 * Use is subjected to license terms.
 *
 * Copyright 2001-2002 (C) GridNode Pte Ltd. All Rights Reserved.
 *
 * File:
 *
 ****************************************************************************
 * Date           Author              Changes
 ****************************************************************************
 * Jun 10 2002   Mathew	        Created
 * Jun 13 2002   Mathew         Repackaged
 * Dec 06 2005   Tam Wei Xiang  i)To remove the depedency on borland xml API.
 *                              Use GN XML api instead.
 *                              ii)Change method marshal(), unmarshal(element) to
 *                              buildElement() and buildModel(element)
 *                              iii) We will use the getParent and setParent method
 *                                   in AbstractBpssModel instead of using XMLObject._getParent
 *                                   and _setParent
 *                              iv) method validate(boolean) has been removed.
 */



/**
 * This file is generated by BorlandXML.
 */
package com.gridnode.pdip.app.deploy.manager.bpss;

import java.util.*;

import com.gridnode.pdip.app.deploy.manager.GWFDeployableList;
import com.gridnode.pdip.app.deploy.manager.IConstants;
import com.gridnode.pdip.app.deploy.manager.util.Logger;
import com.gridnode.pdip.app.deploy.manager.util.Utilities;
import com.gridnode.pdip.app.deploy.manager.util.XmlEntityResolver;
import com.gridnode.pdip.base.gwfbase.bpss.helpers.BpssDefinitionCache;
import com.gridnode.pdip.base.gwfbase.bpss.model.*;
import com.gridnode.pdip.framework.db.AbstractEntityHandler;
import com.gridnode.pdip.framework.db.EntityHandlerFactory;
import com.gridnode.pdip.framework.db.filter.DataFilterImpl;
import com.gridnode.pdip.framework.db.filter.IDataFilter;
import com.gridnode.pdip.framework.exceptions.domain.GWFException;
import com.gridnode.xml.adapters.GNAttribute;
import com.gridnode.xml.adapters.GNElement;
import com.gridnode.xml.adapters.GNXMLDocumentUtility;

/**
 * The ProcessSpecification class represents the element "ProcessSpecification" with the content
 * model defined as follows:
 * <p>
 * &lt;!ELEMENT ProcessSpecification (Documentation*,SubstitutionSet*,(Include*|BusinessDocument*|ProcessSpecification*|Package|BinaryCollaboration|BusinessTransaction|MultiPartyCollaboration)*)&gt;<br>
 */
public class ProcessSpecification
  extends AbstractBpssModel
  implements IConstants
{

  /**
	 * Serial Version UID
	 */
	private static final long serialVersionUID = -2303798997065866674L;

	/** xml tag name of this element. */
  public static String _tagName = "ProcessSpecification";
  
  public GNAttribute version = GNXMLDocumentUtility.newAttribute("version", "");
  
  public GNAttribute name = GNXMLDocumentUtility.newAttribute("name", "");
  
  public GNAttribute uuid = GNXMLDocumentUtility.newAttribute("uuid", "");
  
  
  /** Defines a list of Documentation objects. */
  protected ArrayList _objDocumentation = new ArrayList();

  /** Defines a list of SubstitutionSet objects. */
  protected ArrayList _objSubstitutionSet = new ArrayList();

  /** Defines a list of Include objects. */
  protected ArrayList _objInclude = new ArrayList();

  /** Defines a list of BusinessDocument objects. */
  protected ArrayList _objBusinessDocument = new ArrayList();

  /** Defines a list of ProcessSpecification objects. */
  protected ArrayList _objProcessSpecification = new ArrayList();

  /** Defines a list of Package objects. */
  protected ArrayList _objPackage = new ArrayList();

  /** Defines a list of BinaryCollaboration objects. */
  protected ArrayList _objBinaryCollaboration = new ArrayList();

  /** Defines a list of BusinessTransaction objects. */
  protected ArrayList _objBusinessTransaction = new ArrayList();

  /** Defines a list of MultiPartyCollaboration objects. */
  protected ArrayList _objMultiPartyCollaboration = new ArrayList();

  /** Public identifier. */
  protected String publicId = "";

  /** System identifier. */
  protected String systemId = "BPSS1.01.dtd";

  protected static final String defaultSystemId = "BPSS1.01.dtd";

  /**
     * Creates an empty ProcessSpecification object
     */
  public ProcessSpecification()
  {
    super();
  }

  /**
     * Gets the value of "version" attribute.
     */
  public String getVersion()
  {
    return version.getValue();
  }

  /**
     * Replaces the existing attribute value with a new value.
     * @param value    New value.
     */
  public void setVersion(String value_)
  {
    version.setValue(value_);
  }

  /**
     * Gets the value of "name" attribute.
     */
  public String getName()
  {
    return name.getValue();
  }

  /**
     * Replaces the existing attribute value with a new value.
     * @param value    New value.
     */
  public void setName(String value_)
  {
    name.setValue(value_);
  }

  /**
     * Gets the value of "uuid" attribute.
     */
  public String getUuid()
  {
    return uuid.getValue();
  }

  /**
     * Replaces the existing attribute value with a new value.
     * @param value    New value.
     */
  public void setUuid(String value_)
  {
    uuid.setValue(value_);
  }

  /**
     * Returns an array of Documentation objects. The length of the returned
     * array is zero if the list of Documentation object is empty.
     */
  public Documentation[] getDocumentation()
  {
    return (Documentation[])_objDocumentation.toArray(new Documentation[0]);
  }

  /**
     * Replaces all existing Documentation objects with a new array of
     * Documentation objects.
     * @param objArray    an array of Documentation objects.
     */
  public void setDocumentation(Documentation[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objDocumentation.clear();
    else
    {
      this._objDocumentation = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the Documentation object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public Documentation getDocumentation(int index)
  {
    return (Documentation)_objDocumentation.get(index);
  }

  /**
     * Replaces an existing Documentation object at the specified index with
     * a new Documentation object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setDocumentation(int index, Documentation obj)
  {
    if (obj == null)
      removeDocumentation(index);
    else
    {
      _objDocumentation.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of Documentation objects in the list.
     */
  public int getDocumentationCount()
  {
    return _objDocumentation.size();
  }

  /**
     * Returns <code>true</code> if there is no Documentation object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoDocumentation()
  {
    return _objDocumentation.size() == 0;
  }

  /**
     * Returns a read-only list of Documentation objects.
     */
  public List getDocumentationList()
  {
    return Collections.unmodifiableList(_objDocumentation);
  }

  /**
     * Adds a new Documentation object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addDocumentation(Documentation obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objDocumentation.add(obj);
  }

  /**
     * Adds a list of new Documentation objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addDocumentation(Collection coDocumentation)
  {
    if (coDocumentation == null)
      return false;
    java.util.Iterator it = coDocumentation.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objDocumentation.addAll(coDocumentation);
  }

  /**
     * Removes an existing Documentation object at the specified index.
     * @return    The removed object.
     */
  public Documentation removeDocumentation(int index)
  {
    return (Documentation)_objDocumentation.remove(index);
  }

  /**
     * Removes the specified Documentation object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeDocumentation(Documentation obj)
  {
    return _objDocumentation.remove(obj);
  }

  /**
     * Clears all Documentation objects from the list.
     */
  public void clearDocumentationList()
  {
    _objDocumentation.clear();
  }

  /**
     * Returns an array of SubstitutionSet objects. The length of the returned
     * array is zero if the list of SubstitutionSet object is empty.
     */
  public SubstitutionSet[] getSubstitutionSet()
  {
    return (SubstitutionSet[])_objSubstitutionSet.toArray(
                 new SubstitutionSet[0]);
  }

  /**
     * Replaces all existing SubstitutionSet objects with a new array of
     * SubstitutionSet objects.
     * @param objArray    an array of SubstitutionSet objects.
     */
  public void setSubstitutionSet(SubstitutionSet[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objSubstitutionSet.clear();
    else
    {
      this._objSubstitutionSet = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the SubstitutionSet object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public SubstitutionSet getSubstitutionSet(int index)
  {
    return (SubstitutionSet)_objSubstitutionSet.get(index);
  }

  /**
     * Replaces an existing SubstitutionSet object at the specified index with
     * a new SubstitutionSet object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setSubstitutionSet(int index, SubstitutionSet obj)
  {
    if (obj == null)
      removeSubstitutionSet(index);
    else
    {
      _objSubstitutionSet.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of SubstitutionSet objects in the list.
     */
  public int getSubstitutionSetCount()
  {
    return _objSubstitutionSet.size();
  }

  /**
     * Returns <code>true</code> if there is no SubstitutionSet object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoSubstitutionSet()
  {
    return _objSubstitutionSet.size() == 0;
  }

  /**
     * Returns a read-only list of SubstitutionSet objects.
     */
  public List getSubstitutionSetList()
  {
    return Collections.unmodifiableList(_objSubstitutionSet);
  }

  /**
     * Adds a new SubstitutionSet object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addSubstitutionSet(SubstitutionSet obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objSubstitutionSet.add(obj);
  }

  /**
     * Adds a list of new SubstitutionSet objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addSubstitutionSet(Collection coSubstitutionSet)
  {
    if (coSubstitutionSet == null)
      return false;
    java.util.Iterator it = coSubstitutionSet.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objSubstitutionSet.addAll(coSubstitutionSet);
  }

  /**
     * Removes an existing SubstitutionSet object at the specified index.
     * @return    The removed object.
     */
  public SubstitutionSet removeSubstitutionSet(int index)
  {
    return (SubstitutionSet)_objSubstitutionSet.remove(index);
  }

  /**
     * Removes the specified SubstitutionSet object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeSubstitutionSet(SubstitutionSet obj)
  {
    return _objSubstitutionSet.remove(obj);
  }

  /**
     * Clears all SubstitutionSet objects from the list.
     */
  public void clearSubstitutionSetList()
  {
    _objSubstitutionSet.clear();
  }

  /**
     * Returns an array of Include objects. The length of the returned
     * array is zero if the list of Include object is empty.
     */
  public Include[] getInclude()
  {
    return (Include[])_objInclude.toArray(new Include[0]);
  }

  /**
     * Replaces all existing Include objects with a new array of
     * Include objects.
     * @param objArray    an array of Include objects.
     */
  public void setInclude(Include[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objInclude.clear();
    else
    {
      this._objInclude = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the Include object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public Include getInclude(int index)
  {
    return (Include)_objInclude.get(index);
  }

  /**
     * Replaces an existing Include object at the specified index with
     * a new Include object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setInclude(int index, Include obj)
  {
    if (obj == null)
      removeInclude(index);
    else
    {
      _objInclude.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of Include objects in the list.
     */
  public int getIncludeCount()
  {
    return _objInclude.size();
  }

  /**
     * Returns <code>true</code> if there is no Include object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoInclude()
  {
    return _objInclude.size() == 0;
  }

  /**
     * Returns a read-only list of Include objects.
     */
  public List getIncludeList()
  {
    return Collections.unmodifiableList(_objInclude);
  }

  /**
     * Adds a new Include object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addInclude(Include obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objInclude.add(obj);
  }

  /**
     * Adds a list of new Include objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addInclude(Collection coInclude)
  {
    if (coInclude == null)
      return false;
    java.util.Iterator it = coInclude.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objInclude.addAll(coInclude);
  }

  /**
     * Removes an existing Include object at the specified index.
     * @return    The removed object.
     */
  public Include removeInclude(int index)
  {
    return (Include)_objInclude.remove(index);
  }

  /**
     * Removes the specified Include object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeInclude(Include obj)
  {
    return _objInclude.remove(obj);
  }

  /**
     * Clears all Include objects from the list.
     */
  public void clearIncludeList()
  {
    _objInclude.clear();
  }

  /**
     * Returns an array of BusinessDocument objects. The length of the returned
     * array is zero if the list of BusinessDocument object is empty.
     */
  public BusinessDocument[] getBusinessDocument()
  {
    return (BusinessDocument[])_objBusinessDocument.toArray(
                 new BusinessDocument[0]);
  }

  /**
     * Replaces all existing BusinessDocument objects with a new array of
     * BusinessDocument objects.
     * @param objArray    an array of BusinessDocument objects.
     */
  public void setBusinessDocument(BusinessDocument[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objBusinessDocument.clear();
    else
    {
      this._objBusinessDocument = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the BusinessDocument object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public BusinessDocument getBusinessDocument(int index)
  {
    return (BusinessDocument)_objBusinessDocument.get(index);
  }

  /**
     * Replaces an existing BusinessDocument object at the specified index with
     * a new BusinessDocument object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setBusinessDocument(int index, BusinessDocument obj)
  {
    if (obj == null)
      removeBusinessDocument(index);
    else
    {
      _objBusinessDocument.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of BusinessDocument objects in the list.
     */
  public int getBusinessDocumentCount()
  {
    return _objBusinessDocument.size();
  }

  /**
     * Returns <code>true</code> if there is no BusinessDocument object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoBusinessDocument()
  {
    return _objBusinessDocument.size() == 0;
  }

  /**
     * Returns a read-only list of BusinessDocument objects.
     */
  public List getBusinessDocumentList()
  {
    return Collections.unmodifiableList(_objBusinessDocument);
  }

  /**
     * Adds a new BusinessDocument object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addBusinessDocument(BusinessDocument obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objBusinessDocument.add(obj);
  }

  /**
     * Adds a list of new BusinessDocument objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addBusinessDocument(Collection coBusinessDocument)
  {
    if (coBusinessDocument == null)
      return false;
    java.util.Iterator it = coBusinessDocument.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objBusinessDocument.addAll(coBusinessDocument);
  }

  /**
     * Removes an existing BusinessDocument object at the specified index.
     * @return    The removed object.
     */
  public BusinessDocument removeBusinessDocument(int index)
  {
    return (BusinessDocument)_objBusinessDocument.remove(index);
  }

  /**
     * Removes the specified BusinessDocument object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeBusinessDocument(BusinessDocument obj)
  {
    return _objBusinessDocument.remove(obj);
  }

  /**
     * Clears all BusinessDocument objects from the list.
     */
  public void clearBusinessDocumentList()
  {
    _objBusinessDocument.clear();
  }

  /**
     * Returns an array of ProcessSpecification objects. The length of the returned
     * array is zero if the list of ProcessSpecification object is empty.
     */
  public ProcessSpecification[] getProcessSpecification()
  {
    return (ProcessSpecification[])_objProcessSpecification.toArray(
                 new ProcessSpecification[0]);
  }

  /**
     * Replaces all existing ProcessSpecification objects with a new array of
     * ProcessSpecification objects.
     * @param objArray    an array of ProcessSpecification objects.
     */
  public void setProcessSpecification(ProcessSpecification[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objProcessSpecification.clear();
    else
    {
      this._objProcessSpecification = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the ProcessSpecification object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public ProcessSpecification getProcessSpecification(int index)
  {
    return (ProcessSpecification)_objProcessSpecification.get(index);
  }

  /**
     * Replaces an existing ProcessSpecification object at the specified index with
     * a new ProcessSpecification object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setProcessSpecification(int index, ProcessSpecification obj)
  {
    if (obj == null)
      removeProcessSpecification(index);
    else
    {
      _objProcessSpecification.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of ProcessSpecification objects in the list.
     */
  public int getProcessSpecificationCount()
  {
    return _objProcessSpecification.size();
  }

  /**
     * Returns <code>true</code> if there is no ProcessSpecification object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoProcessSpecification()
  {
    return _objProcessSpecification.size() == 0;
  }

  /**
     * Returns a read-only list of ProcessSpecification objects.
     */
  public List getProcessSpecificationList()
  {
    return Collections.unmodifiableList(_objProcessSpecification);
  }

  /**
     * Adds a new ProcessSpecification object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addProcessSpecification(ProcessSpecification obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objProcessSpecification.add(obj);
  }

  /**
     * Adds a list of new ProcessSpecification objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addProcessSpecification(Collection coProcessSpecification)
  {
    if (coProcessSpecification == null)
      return false;
    java.util.Iterator it = coProcessSpecification.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objProcessSpecification.addAll(coProcessSpecification);
  }

  /**
     * Removes an existing ProcessSpecification object at the specified index.
     * @return    The removed object.
     */
  public ProcessSpecification removeProcessSpecification(int index)
  {
    return (ProcessSpecification)_objProcessSpecification.remove(index);
  }

  /**
     * Removes the specified ProcessSpecification object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeProcessSpecification(ProcessSpecification obj)
  {
    return _objProcessSpecification.remove(obj);
  }

  /**
     * Clears all ProcessSpecification objects from the list.
     */
  public void clearProcessSpecificationList()
  {
    _objProcessSpecification.clear();
  }

  /**
     * Returns an array of Package objects. The length of the returned
     * array is zero if the list of Package object is empty.
     */
  public Package[] getPackage()
  {
    return (Package[])_objPackage.toArray(new Package[0]);
  }

  /**
     * Replaces all existing Package objects with a new array of
     * Package objects.
     * @param objArray    an array of Package objects.
     */
  public void setPackage(Package[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objPackage.clear();
    else
    {
      this._objPackage = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the Package object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public Package getPackage(int index)
  {
    return (Package)_objPackage.get(index);
  }

  /**
     * Replaces an existing Package object at the specified index with
     * a new Package object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setPackage(int index, Package obj)
  {
    if (obj == null)
      removePackage(index);
    else
    {
      _objPackage.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of Package objects in the list.
     */
  public int getPackageCount()
  {
    return _objPackage.size();
  }

  /**
     * Returns <code>true</code> if there is no Package object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoPackage()
  {
    return _objPackage.size() == 0;
  }

  /**
     * Returns a read-only list of Package objects.
     */
  public List getPackageList()
  {
    return Collections.unmodifiableList(_objPackage);
  }

  /**
     * Adds a new Package object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addPackage(Package obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objPackage.add(obj);
  }

  /**
     * Adds a list of new Package objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addPackage(Collection coPackage)
  {
    if (coPackage == null)
      return false;
    java.util.Iterator it = coPackage.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objPackage.addAll(coPackage);
  }

  /**
     * Removes an existing Package object at the specified index.
     * @return    The removed object.
     */
  public Package removePackage(int index)
  {
    return (Package)_objPackage.remove(index);
  }

  /**
     * Removes the specified Package object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removePackage(Package obj)
  {
    return _objPackage.remove(obj);
  }

  /**
     * Clears all Package objects from the list.
     */
  public void clearPackageList()
  {
    _objPackage.clear();
  }

  /**
     * Returns an array of BinaryCollaboration objects. The length of the returned
     * array is zero if the list of BinaryCollaboration object is empty.
     */
  public BinaryCollaboration[] getBinaryCollaboration()
  {
    return (BinaryCollaboration[])_objBinaryCollaboration.toArray(
                 new BinaryCollaboration[0]);
  }

  /**
     * Replaces all existing BinaryCollaboration objects with a new array of
     * BinaryCollaboration objects.
     * @param objArray    an array of BinaryCollaboration objects.
     */
  public void setBinaryCollaboration(BinaryCollaboration[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objBinaryCollaboration.clear();
    else
    {
      this._objBinaryCollaboration = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the BinaryCollaboration object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public BinaryCollaboration getBinaryCollaboration(int index)
  {
    return (BinaryCollaboration)_objBinaryCollaboration.get(index);
  }

  /**
     * Replaces an existing BinaryCollaboration object at the specified index with
     * a new BinaryCollaboration object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setBinaryCollaboration(int index, BinaryCollaboration obj)
  {
    if (obj == null)
      removeBinaryCollaboration(index);
    else
    {
      _objBinaryCollaboration.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of BinaryCollaboration objects in the list.
     */
  public int getBinaryCollaborationCount()
  {
    return _objBinaryCollaboration.size();
  }

  /**
     * Returns <code>true</code> if there is no BinaryCollaboration object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoBinaryCollaboration()
  {
    return _objBinaryCollaboration.size() == 0;
  }

  /**
     * Returns a read-only list of BinaryCollaboration objects.
     */
  public List getBinaryCollaborationList()
  {
    return Collections.unmodifiableList(_objBinaryCollaboration);
  }

  /**
     * Adds a new BinaryCollaboration object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addBinaryCollaboration(BinaryCollaboration obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objBinaryCollaboration.add(obj);
  }

  /**
     * Adds a list of new BinaryCollaboration objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addBinaryCollaboration(Collection coBinaryCollaboration)
  {
    if (coBinaryCollaboration == null)
      return false;
    java.util.Iterator it = coBinaryCollaboration.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objBinaryCollaboration.addAll(coBinaryCollaboration);
  }

  /**
     * Removes an existing BinaryCollaboration object at the specified index.
     * @return    The removed object.
     */
  public BinaryCollaboration removeBinaryCollaboration(int index)
  {
    return (BinaryCollaboration)_objBinaryCollaboration.remove(index);
  }

  /**
     * Removes the specified BinaryCollaboration object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeBinaryCollaboration(BinaryCollaboration obj)
  {
    return _objBinaryCollaboration.remove(obj);
  }

  /**
     * Clears all BinaryCollaboration objects from the list.
     */
  public void clearBinaryCollaborationList()
  {
    _objBinaryCollaboration.clear();
  }

  /**
     * Returns an array of BusinessTransaction objects. The length of the returned
     * array is zero if the list of BusinessTransaction object is empty.
     */
  public BusinessTransaction[] getBusinessTransaction()
  {
    return (BusinessTransaction[])_objBusinessTransaction.toArray(
                 new BusinessTransaction[0]);
  }

  /**
     * Replaces all existing BusinessTransaction objects with a new array of
     * BusinessTransaction objects.
     * @param objArray    an array of BusinessTransaction objects.
     */
  public void setBusinessTransaction(BusinessTransaction[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objBusinessTransaction.clear();
    else
    {
      this._objBusinessTransaction = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the BusinessTransaction object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public BusinessTransaction getBusinessTransaction(int index)
  {
    return (BusinessTransaction)_objBusinessTransaction.get(index);
  }

  /**
     * Replaces an existing BusinessTransaction object at the specified index with
     * a new BusinessTransaction object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setBusinessTransaction(int index, BusinessTransaction obj)
  {
    if (obj == null)
      removeBusinessTransaction(index);
    else
    {
      _objBusinessTransaction.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of BusinessTransaction objects in the list.
     */
  public int getBusinessTransactionCount()
  {
    return _objBusinessTransaction.size();
  }

  /**
     * Returns <code>true</code> if there is no BusinessTransaction object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoBusinessTransaction()
  {
    return _objBusinessTransaction.size() == 0;
  }

  /**
     * Returns a read-only list of BusinessTransaction objects.
     */
  public List getBusinessTransactionList()
  {
    return Collections.unmodifiableList(_objBusinessTransaction);
  }

  /**
     * Adds a new BusinessTransaction object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addBusinessTransaction(BusinessTransaction obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objBusinessTransaction.add(obj);
  }

  /**
     * Adds a list of new BusinessTransaction objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addBusinessTransaction(Collection coBusinessTransaction)
  {
    if (coBusinessTransaction == null)
      return false;
    java.util.Iterator it = coBusinessTransaction.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objBusinessTransaction.addAll(coBusinessTransaction);
  }

  /**
     * Removes an existing BusinessTransaction object at the specified index.
     * @return    The removed object.
     */
  public BusinessTransaction removeBusinessTransaction(int index)
  {
    return (BusinessTransaction)_objBusinessTransaction.remove(index);
  }

  /**
     * Removes the specified BusinessTransaction object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeBusinessTransaction(BusinessTransaction obj)
  {
    return _objBusinessTransaction.remove(obj);
  }

  /**
     * Clears all BusinessTransaction objects from the list.
     */
  public void clearBusinessTransactionList()
  {
    _objBusinessTransaction.clear();
  }

  /**
     * Returns an array of MultiPartyCollaboration objects. The length of the returned
     * array is zero if the list of MultiPartyCollaboration object is empty.
     */
  public MultiPartyCollaboration[] getMultiPartyCollaboration()
  {
    return (MultiPartyCollaboration[])_objMultiPartyCollaboration.toArray(
                 new MultiPartyCollaboration[0]);
  }

  /**
     * Replaces all existing MultiPartyCollaboration objects with a new array of
     * MultiPartyCollaboration objects.
     * @param objArray    an array of MultiPartyCollaboration objects.
     */
  public void setMultiPartyCollaboration(MultiPartyCollaboration[] objArray)
  {
    if (objArray == null || objArray.length == 0)
      this._objMultiPartyCollaboration.clear();
    else
    {
      this._objMultiPartyCollaboration = new ArrayList(Arrays.asList(objArray));
      for (int i = 0; i < objArray.length; i++)
      {
      	
        if (objArray[i] != null)
          objArray[i].setParent(this);
          
      }
    }
  }

  /**
     * Gets the MultiPartyCollaboration object at the specified index.
     * @param index    index of the returned object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public MultiPartyCollaboration getMultiPartyCollaboration(int index)
  {
    return (MultiPartyCollaboration)_objMultiPartyCollaboration.get(index);
  }

  /**
     * Replaces an existing MultiPartyCollaboration object at the specified index with
     * a new MultiPartyCollaboration object.
     * @param index    index of replaced object.
     * @throws IndexOutOfBoundsException    if index is out of range.
     */
  public void setMultiPartyCollaboration(int index,
                                         MultiPartyCollaboration obj)
  {
    if (obj == null)
      removeMultiPartyCollaboration(index);
    else
    {
      _objMultiPartyCollaboration.set(index, obj);
      obj.setParent(this);
    }
  }

  /**
     * Returns the number of MultiPartyCollaboration objects in the list.
     */
  public int getMultiPartyCollaborationCount()
  {
    return _objMultiPartyCollaboration.size();
  }

  /**
     * Returns <code>true</code> if there is no MultiPartyCollaboration object in the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean isNoMultiPartyCollaboration()
  {
    return _objMultiPartyCollaboration.size() == 0;
  }

  /**
     * Returns a read-only list of MultiPartyCollaboration objects.
     */
  public List getMultiPartyCollaborationList()
  {
    return Collections.unmodifiableList(_objMultiPartyCollaboration);
  }

  /**
     * Adds a new MultiPartyCollaboration object at the end of the list.
     * @return <code>true</code> if the new object is added to the list; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean addMultiPartyCollaboration(MultiPartyCollaboration obj)
  {
    if (obj == null)
      return false;
    obj.setParent(this);
    return _objMultiPartyCollaboration.add(obj);
  }

  /**
     * Adds a list of new MultiPartyCollaboration objects at the end of the list.
     * @return <code>true</code> if the list was changed; otherwise, the method
     * returns <code>false</code>.
     */
  public boolean addMultiPartyCollaboration(Collection coMultiPartyCollaboration)
  {
    if (coMultiPartyCollaboration == null)
      return false;
    java.util.Iterator it = coMultiPartyCollaboration.iterator();
    while (it.hasNext())
    {
      Object obj = it.next();
      
      if (obj != null && obj instanceof AbstractBpssModel)
        ((AbstractBpssModel)obj).setParent(this);
        
    }
    return _objMultiPartyCollaboration.addAll(coMultiPartyCollaboration);
  }

  /**
     * Removes an existing MultiPartyCollaboration object at the specified index.
     * @return    The removed object.
     */
  public MultiPartyCollaboration removeMultiPartyCollaboration(int index)
  {
    return (MultiPartyCollaboration)_objMultiPartyCollaboration.remove(index);
  }

  /**
     * Removes the specified MultiPartyCollaboration object.
     * @return <code>true</code> if this list contains the object; otherwise,
     * the method returns <code>false</code>.
     */
  public boolean removeMultiPartyCollaboration(MultiPartyCollaboration obj)
  {
    return _objMultiPartyCollaboration.remove(obj);
  }

  /**
     * Clears all MultiPartyCollaboration objects from the list.
     */
  public void clearMultiPartyCollaborationList()
  {
    _objMultiPartyCollaboration.clear();
  }

  /**
     * Gets public identifier.
     */
  public String getPublicId()
  {
    return publicId;
  }

  /**
     * Sets public identifier.
     */
  public void setPublicId(String publicId)
  {
    this.publicId = publicId;
  }

  /**
     * Gets system identifier.
     */
  public String getSystemId()
  {
    return systemId;
  }

  /**
     * Sets system identifier.
     */
  public void setSystemId(String systemId)
  {
    this.systemId = systemId;
  }

  /**
     * Marshals this object to an element.
     */
  /*
  public GNElement marshal()
  {
    GNElement elem = GNXMLDocumentUtility.newElement(get_TagName());

    ///** Marshals "version" attribute 
    elem.addAttribute(version);

    ///** Marshals "name" attribute 
    elem.addAttribute(name);

    ///** Marshals "uuid" attribute 
    elem.addAttribute(uuid);

    ///** Marshals a list of Documentation objects to elements 
    Iterator it1 = _objDocumentation.iterator();
    while (it1.hasNext())
    {
      Documentation obj = (Documentation)it1.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    ///** Marshals a list of SubstitutionSet objects to elements 
    Iterator it2 = _objSubstitutionSet.iterator();
    while (it2.hasNext())
    {
      SubstitutionSet obj = (SubstitutionSet)it2.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    ///** Marshals a list of Include objects to elements 
    Iterator it3 = _objInclude.iterator();
    while (it3.hasNext())
    {
      Include obj = (Include)it3.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    ///** Marshals a list of BusinessDocument objects to elements 
    Iterator it4 = _objBusinessDocument.iterator();
    while (it4.hasNext())
    {
      BusinessDocument obj = (BusinessDocument)it4.next();
      if (obj != null)
        elem.addContent(obj.marshal());
    }

    ///** Marshals a list of ProcessSpecification objects to elements 
    Iterator it5 = _objProcessSpecification.iterator();
    while (it5.hasNext())
    {
      ProcessSpecification obj = (ProcessSpecification)it5.next();
      if (obj != null)
        elem.addContent(obj.marshal());
    }

    ///** Marshals a list of Package objects to elements 
    Iterator it6 = _objPackage.iterator();
    while (it6.hasNext())
    {
      Package obj = (Package)it6.next();
      if (obj != null)
        elem.addContent(obj.marshal());
    }

    ///** Marshals a list of BinaryCollaboration objects to elements 
    Iterator it7 = _objBinaryCollaboration.iterator();
    while (it7.hasNext())
    {
      BinaryCollaboration obj = (BinaryCollaboration)it7.next();
      if (obj != null)
        elem.addContent(obj.marshal());
    }

    ///** Marshals a list of BusinessTransaction objects to elements 
    Iterator it8 = _objBusinessTransaction.iterator();
    while (it8.hasNext())
    {
      BusinessTransaction obj = (BusinessTransaction)it8.next();
      if (obj != null)
        elem.addContent(obj.marshal());
    }

    ///** Marshals a list of MultiPartyCollaboration objects to elements 
    Iterator it9 = _objMultiPartyCollaboration.iterator();
    while (it9.hasNext())
    {
      MultiPartyCollaboration obj = (MultiPartyCollaboration)it9.next();
      if (obj != null)
        elem.addContent(obj.marshal());
    }
    return elem;
  } */

  /**
     * Unmarshals the specified "ProcessSpecification" element back to a ProcessSpecification object.
     */
  /*
  public static ProcessSpecification unmarshal(com.borland.xml.toolkit.Element elem)
  {
    if (elem == null)
      return null;
    ProcessSpecification __objProcessSpecification = new ProcessSpecification();
    if (__objProcessSpecification != null)  //found the element?
    {

      /** Unmarshals "version" attribute 
      __objProcessSpecification.version.setValue(elem.getAttribute("version"));

      /** Unmarshals "name" attribute 
      __objProcessSpecification.name.setValue(elem.getAttribute("name"));

      /** Unmarshals "uuid" attribute 
      __objProcessSpecification.uuid.setValue(elem.getAttribute("uuid"));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to Documentation objects. 
    Iterator it1 = elem.getChildren(Documentation._tagName).iterator();
    while (it1.hasNext())
      __objProcessSpecification.addDocumentation(Documentation.unmarshal(
                                                     (com.borland.xml.toolkit.Element)it1.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to SubstitutionSet objects. 
    Iterator it2 = elem.getChildren(SubstitutionSet._tagName).iterator();
    while (it2.hasNext())
      __objProcessSpecification.addSubstitutionSet(SubstitutionSet.unmarshal(
                                                       (com.borland.xml.toolkit.Element)it2.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to Include objects. 
    Iterator it3 = elem.getChildren(Include._tagName).iterator();
    while (it3.hasNext())
      __objProcessSpecification.addInclude(Include.unmarshal(
                                               (com.borland.xml.toolkit.Element)it3.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to BusinessDocument objects. 
    Iterator it4 = elem.getChildren(BusinessDocument._tagName).iterator();
    while (it4.hasNext())
      __objProcessSpecification.addBusinessDocument(BusinessDocument.unmarshal(
                                                        (com.borland.xml.toolkit.Element)it4.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to ProcessSpecification objects. 
    Iterator it5 = elem.getChildren(ProcessSpecification._tagName).iterator();
    while (it5.hasNext())
      __objProcessSpecification.addProcessSpecification(ProcessSpecification.unmarshal(
                                                            (com.borland.xml.toolkit.Element)it5.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to Package objects. 
    Iterator it6 = elem.getChildren(Package._tagName).iterator();
    while (it6.hasNext())
      __objProcessSpecification.addPackage(Package.unmarshal(
                                               (com.borland.xml.toolkit.Element)it6.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to BinaryCollaboration objects. 
    Iterator it7 = elem.getChildren(BinaryCollaboration._tagName).iterator();
    while (it7.hasNext())
      __objProcessSpecification.addBinaryCollaboration(BinaryCollaboration.unmarshal(
                                                           (com.borland.xml.toolkit.Element)it7.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to BusinessTransaction objects. 
    Iterator it8 = elem.getChildren(BusinessTransaction._tagName).iterator();
    while (it8.hasNext())
      __objProcessSpecification.addBusinessTransaction(BusinessTransaction.unmarshal(
                                                           (com.borland.xml.toolkit.Element)it8.next()));

    /** Unmarshals a list of "<<_tagName_>>" elements back to MultiPartyCollaboration objects. 
    Iterator it9 = elem.getChildren(MultiPartyCollaboration._tagName).iterator();
    while (it9.hasNext())
      __objProcessSpecification.addMultiPartyCollaboration(MultiPartyCollaboration.unmarshal(
                                                               (com.borland.xml.toolkit.Element)it9.next()));
    return __objProcessSpecification;
  } */

  /**
     * Validates this object. If you pass <code>true</code> to this method, it
     * checks for the first error and stops. On the other hand, if you pass
     * <code>false</code> to this method, it collects all the errors by
     * visiting every available elements.
     * @param firstError    <code>true</code> to exit this method when the first error
     * is found; <code>false</code> to collect all errors.
     * @return com.borland.xml.toolkit.ErrorList    A list that contains one or more errors.
     * @see com.borland.xml.toolkit.XmlObject#validate()
     * @see com.borland.xml.toolkit.XmlObject#isValid()
     * @see com.borland.xml.toolkit.ErrorList
     */
  /*
  public com.borland.xml.toolkit.ErrorList validate(boolean firstError)
  {
    com.borland.xml.toolkit.ErrorList errors = new com.borland.xml.toolkit.ErrorList();

    /** Documentation is zero or more 
    Iterator it1 = _objDocumentation.iterator();
    while (it1.hasNext())
    {
      Documentation obj = (Documentation)it1.next();
      if (obj != null)
      {
        errors.add(obj.validate(firstError));
        if (firstError && errors.size() > 0)
          return errors;
      }
    }

    /** SubstitutionSet is zero or more 
    Iterator it2 = _objSubstitutionSet.iterator();
    while (it2.hasNext())
    {
      SubstitutionSet obj = (SubstitutionSet)it2.next();
      if (obj != null)
      {
        errors.add(obj.validate(firstError));
        if (firstError && errors.size() > 0)
          return errors;
      }
    }

    /** "or" block 
    if (_objInclude.size() > 0 || _objBusinessDocument.size() > 0 ||
        _objProcessSpecification.size() > 0 || _objPackage.size() > 0 ||
        _objBinaryCollaboration.size() > 0 ||
        _objBusinessTransaction.size() > 0)
    {

      /** "or" block 
      if (_objInclude.size() > 0 || _objBusinessDocument.size() > 0 ||
          _objProcessSpecification.size() > 0 || _objPackage.size() > 0 ||
          _objBinaryCollaboration.size() > 0)
      {

        /** "or" block 
        if (_objInclude.size() > 0 || _objBusinessDocument.size() > 0 ||
            _objProcessSpecification.size() > 0 || _objPackage.size() > 0)
        {

          /** "or" block 
          if (_objInclude.size() > 0 || _objBusinessDocument.size() > 0 ||
              _objProcessSpecification.size() > 0)
          {

            /** "or" block 
            if (_objInclude.size() > 0 || _objBusinessDocument.size() > 0)
            {

              /** "or" block 
              if (_objInclude.size() > 0)
              {

                /** Include is zero or more 
                Iterator it3 = _objInclude.iterator();
                while (it3.hasNext())
                {
                  Include obj = (Include)it3.next();
                  if (obj != null)
                  {
                    errors.add(obj.validate(firstError));
                    if (firstError && errors.size() > 0)
                      return errors;
                  }
                }
              }
              if (_objBusinessDocument.size() > 0)
              {

                /** BusinessDocument is zero or more 
                Iterator it4 = _objBusinessDocument.iterator();
                while (it4.hasNext())
                {
                  BusinessDocument obj = (BusinessDocument)it4.next();
                  if (obj != null)
                  {
                    errors.add(obj.validate(firstError));
                    if (firstError && errors.size() > 0)
                      return errors;
                  }
                }
              }
            }
            if (_objProcessSpecification.size() > 0)
            {

              /** ProcessSpecification is zero or more 
              Iterator it5 = _objProcessSpecification.iterator();
              while (it5.hasNext())
              {
                ProcessSpecification obj = (ProcessSpecification)it5.next();
                if (obj != null)
                {
                  errors.add(obj.validate(firstError));
                  if (firstError && errors.size() > 0)
                    return errors;
                }
              }
            }
          }
          if (_objPackage.size() > 0)
          {

            /** Package is zero or more 
            Iterator it6 = _objPackage.iterator();
            while (it6.hasNext())
            {
              Package obj = (Package)it6.next();
              if (obj != null)
              {
                errors.add(obj.validate(firstError));
                if (firstError && errors.size() > 0)
                  return errors;
              }
            }
          }
        }
        if (_objBinaryCollaboration.size() > 0)
        {

          /** BinaryCollaboration is zero or more 
          Iterator it7 = _objBinaryCollaboration.iterator();
          while (it7.hasNext())
          {
            BinaryCollaboration obj = (BinaryCollaboration)it7.next();
            if (obj != null)
            {
              errors.add(obj.validate(firstError));
              if (firstError && errors.size() > 0)
                return errors;
            }
          }
        }
      }
      if (_objBusinessTransaction.size() > 0)
      {

        /** BusinessTransaction is zero or more 
        Iterator it8 = _objBusinessTransaction.iterator();
        while (it8.hasNext())
        {
          BusinessTransaction obj = (BusinessTransaction)it8.next();
          if (obj != null)
          {
            errors.add(obj.validate(firstError));
            if (firstError && errors.size() > 0)
              return errors;
          }
        }
      }
    }
    if (_objMultiPartyCollaboration.size() > 0)
    {

      /** MultiPartyCollaboration is zero or more 
      Iterator it9 = _objMultiPartyCollaboration.iterator();
      while (it9.hasNext())
      {
        MultiPartyCollaboration obj = (MultiPartyCollaboration)it9.next();
        if (obj != null)
        {
          errors.add(obj.validate(firstError));
          if (firstError && errors.size() > 0)
            return errors;
        }
      }
    }
    return errors.size() == 0 ? null : errors;
  } */

  /**
     * Returns a list containing all child elements. Each element in the list is a subclass
     * of XmlObject.
     */
  public java.util.List _getChildren()
  {
    java.util.List children = new java.util.ArrayList();

    /** adds _objDocumentation */
    if (_objDocumentation != null && _objDocumentation.size() > 0)
      children.add(_objDocumentation);

    /** adds _objSubstitutionSet */
    if (_objSubstitutionSet != null && _objSubstitutionSet.size() > 0)
      children.add(_objSubstitutionSet);

    /** adds _objInclude */
    if (_objInclude != null && _objInclude.size() > 0)
      children.add(_objInclude);

    /** adds _objBusinessDocument */
    if (_objBusinessDocument != null && _objBusinessDocument.size() > 0)
      children.add(_objBusinessDocument);

    /** adds _objProcessSpecification */
    if (_objProcessSpecification != null &&
        _objProcessSpecification.size() > 0)
      children.add(_objProcessSpecification);

    /** adds _objPackage */
    if (_objPackage != null && _objPackage.size() > 0)
      children.add(_objPackage);

    /** adds _objBinaryCollaboration */
    if (_objBinaryCollaboration != null &&
        _objBinaryCollaboration.size() > 0)
      children.add(_objBinaryCollaboration);

    /** adds _objBusinessTransaction */
    if (_objBusinessTransaction != null &&
        _objBusinessTransaction.size() > 0)
      children.add(_objBusinessTransaction);

    /** adds _objMultiPartyCollaboration */
    if (_objMultiPartyCollaboration != null &&
        _objMultiPartyCollaboration.size() > 0)
      children.add(_objMultiPartyCollaboration);
    return children;
  }

  /**
     * Gets the tag name of this element.
     */
  public String get_TagName()
  {
    return _tagName;
  }

  /**
   * DOCUMENT ME!
   *
   * @return DOCUMENT ME!
   * @throws GWFException DOCUMENT ME!
   */
  /*
  public int deploy()
             throws GWFException
  {
    System.out.println("Inside deploy of ProcessSpecification");
    Hashtable incomplete = new Hashtable();
    //Ready a list of entities to deploy to
    java.util.Vector all = new java.util.Vector(9);
    //Create 9 empty lists
    for (int i = 0; i < 9; i++)
    {
      GWFDeployableList list = new GWFDeployableList();
      all.add(list);
    }
    //Populate the lists
    ((GWFDeployableList)all.get(0)).addAll(java.util.Arrays.asList(this.getBinaryCollaboration()));
    ((GWFDeployableList)all.get(1)).addAll(java.util.Arrays.asList(this.getBusinessDocument()));
    ((GWFDeployableList)all.get(2)).addAll(java.util.Arrays.asList(this.getBusinessTransaction()));
    ((GWFDeployableList)all.get(3)).addAll(java.util.Arrays.asList(this.getDocumentation()));
    ((GWFDeployableList)all.get(4)).addAll(java.util.Arrays.asList(this.getInclude()));
    ((GWFDeployableList)all.get(5)).addAll(java.util.Arrays.asList(this.getMultiPartyCollaboration()));
    ((GWFDeployableList)all.get(6)).addAll(java.util.Arrays.asList(this.getSubstitutionSet()));
    ((GWFDeployableList)all.get(7)).addAll(java.util.Arrays.asList(this.getPackage()));
    ((GWFDeployableList)all.get(8)).addAll(java.util.Arrays.asList(this.getProcessSpecification()));
    int finalResult = 0;
    try
    {
      //Query for existing specs
      IDataFilter filter = new DataFilterImpl();
      filter.addSingleFilter(null, IBpssProcessSpecification.UUID,
                             filter.getEqualOperator(), this.getUuid(), false);
      filter.addSingleFilter(filter.getAndConnector(),
                             IBpssProcessSpecification.VERSION,
                             filter.getEqualOperator(), this.getVersion(),
                             false);
      AbstractEntityHandler handler = EntityHandlerFactory.getHandlerFor(
                                          BpssProcessSpecification.ENTITY_NAME,
                                          true);
      Collection bpssProcSpecColl = handler.getEntityByFilter(filter);
      if (bpssProcSpecColl.isEmpty())
      {
        //new spec, so it can be deployed
        BpssProcessSpecification bpssProcSpec = new BpssProcessSpecification();
        //bpssProcSpec.setSpecName(this.getName().substring(1,this.getName().length()));
        bpssProcSpec.setSpecName(this.getName());
        bpssProcSpec.setSpecUUId(this.getUuid());
        bpssProcSpec.setSpecVersion(this.getVersion());
        bpssProcSpec.setSpecTimestamp(new java.sql.Time(System.currentTimeMillis()).toString());
        bpssProcSpec = (BpssProcessSpecification)handler.createEntity(
                           bpssProcSpec);
        
        //Deploy only those lists that are not empty
        for (int i = 0; i < 9; i++)
        {
          System.out.println(all.get(i));
          if ((GWFDeployableList)all.get(i) != null)
          {
            GWFDeployableList data = (GWFDeployableList)all.get(i);
            int result = data.deploy(bpssProcSpec.getUId(), incomplete);
            finalResult = Utilities.combineResult(finalResult, result);
          }
        }
        Utilities.parseAgain(incomplete, bpssProcSpec.getUId());
        Utilities.parseMultiPartyCollaboration(incomplete,
                                               bpssProcSpec.getUId());
      }
      else if (bpssProcSpecColl.size() > 1)
      {
        throw new GWFException();
      }
      else
      {
        Iterator it = bpssProcSpecColl.iterator();
        BpssProcessSpecification matchSpec = (BpssProcessSpecification)it.next();
        if (matchSpec == null)
        {
          throw new GWFException();
        }
        //update existing specs
        // TODO: Check if any of the specifications is currently instantiated in runtime
        // if instantiated, return with GWF_NOTHING_PERFORMED
        //Otherwise undeploy the other tables before deploying new specs
        undeploy();
        BpssProcessSpecification bpssProcSpec = new BpssProcessSpecification();
        //bpssProcSpec.setSpecName(this.getName().substring(1,this.getName().length()));
        bpssProcSpec.setSpecName(this.getName());
        bpssProcSpec.setSpecUUId(this.getUuid());
        bpssProcSpec.setSpecVersion(this.getVersion());
        bpssProcSpec.setSpecTimestamp(new java.sql.Date(System.currentTimeMillis()).toString());
        bpssProcSpec = (BpssProcessSpecification)handler.createEntity(
                           bpssProcSpec);
        
        //Deploy only those lists that are not empty
        for (int i = 0; i < 9; i++)
        {
          if ((GWFDeployableList)all.get(i) != null)
          {
            GWFDeployableList data = (GWFDeployableList)all.get(i);
            int result = data.deploy(bpssProcSpec.getUId(), incomplete);
            finalResult = Utilities.combineResult(finalResult, result);
          }
        }
        Utilities.parseAgain(incomplete, bpssProcSpec.getUId());
        Utilities.parseMultiPartyCollaboration(incomplete,
                                               bpssProcSpec.getUId());
      }
    }
    catch (Throwable th)
    {
      Logger.err("[ProcessSpecification.deploy] Error, Unable to deploy " + this.getName()+", Uuid="+this.getUuid()+", Version="+this.getVersion() ,th); 
      //TODO handle RemoteException, ParseException
    }
    return finalResult;
  } */

  /**
   * DOCUMENT ME!
   *
   * @return DOCUMENT ME!
   * @throws GWFException DOCUMENT ME!
   */
  /*
  public int undeploy()
               throws GWFException
  {
    int finalResult = 0;
    try
    {
      //Query for existing specs
      IDataFilter filter = new DataFilterImpl();
      filter.addSingleFilter(null, IBpssProcessSpecification.UUID,
                             filter.getEqualOperator(), this.getUuid(), false);
      filter.addSingleFilter(filter.getAndConnector(),
                             IBpssProcessSpecification.VERSION,
                             filter.getEqualOperator(), this.getVersion(),
                             false);
      AbstractEntityHandler handler = EntityHandlerFactory.getHandlerFor(
                                          BpssProcessSpecification.ENTITY_NAME,
                                          true);
      Collection bpssProcSpecColl = handler.getEntityByFilter(filter);
      if (bpssProcSpecColl.isEmpty())
      {
        //new spec has not been deployed before, so cannot undeploy
        return GWF_NOTHING_PERFORMED;
      }
      else if (bpssProcSpecColl.size() > 1)
      {
        throw new GWFException("More than one bpssProcSpec exists");
      }
      else
      {
        Iterator it = bpssProcSpecColl.iterator();
        BpssProcessSpecification matchSpec = (BpssProcessSpecification)it.next();
        BpssDefinitionCache.removeBpssDefinitionCache(matchSpec.getSpecName(),matchSpec.getSpecVersion(),matchSpec.getSpecUUId());
        filter = new DataFilterImpl();
        filter.addSingleFilter(null, IBpssProcessSpecEntry.SPEC_UID,
                               filter.getEqualOperator(),
                               new Long(matchSpec.getUId()), false);
        AbstractEntityHandler entryHandler = EntityHandlerFactory.getHandlerFor(
                                                 BpssProcessSpecEntry.ENTITY_NAME,
                                                 true);
        Collection bpssProcSpecEntryColl = entryHandler.getEntityByFilter(
                                               filter);
        it = bpssProcSpecEntryColl.iterator();
        while (it.hasNext())
        {
          BpssProcessSpecEntry deployedSpecEntry = (BpssProcessSpecEntry)it.next();
          //never compare deployedSpecEntry with the one in the xml, just remove
          AbstractEntityHandler entityHandler = EntityHandlerFactory.getHandlerFor(deployedSpecEntry.getEntryType(),
                                                                                   true);
          
          //Mahesh 20041203 : leave entry for BpssBinaryCollaboration so that we can use this point to
          //        runtime processes of previous vierion definitions          
          if(!deployedSpecEntry.getEntryType().equals(BpssBinaryCollaboration.ENTITY_NAME))
          { 
            entityHandler.remove(new Long(deployedSpecEntry.getEntryUId()));
            entryHandler.remove(new Long(deployedSpecEntry.getUId()));         
          } 
          else
          {  
            Logger.debug("[ProcessSpecification.undeploy] Not deleting BpssProcessSpecEntry for BpssBinaryCollaboration, UId="+deployedSpecEntry.getUId()+", BpssBinaryCollaborationUId="+deployedSpecEntry.getEntryUId());
            try
            {
              entityHandler.remove(new Long(deployedSpecEntry.getEntryUId()));
            }
            catch(Throwable th)
            {
              Logger.debug("[ProcessSpecification.undeploy] Warning!  while deleting BpssBinaryCollaboration, Error: "+th.getMessage());
            }
          }
        }
        //Mahesh 20041203 : leave this record and update version to DELETED so that we can use this point to
        //        runtime processes of previous vierion definitions
        matchSpec.setSpecVersion("DELETED");
        handler.update(matchSpec);
      }
    }
    catch (Throwable th)
    {
      //TODO handle RemoteException, ParseException
      Logger.err("[ProcessSpecification.undeploy] error, Unable to deploy " + this.getName()+", Uuid="+this.getUuid()+", Version="+this.getVersion(),th);
      throw new GWFException(th);
    }
    return finalResult;
  } */
  
  /**
   * TWX: Unmarshals the specified "ProcessSpecification" element back to a ProcessSpecification object.
   */
  public ProcessSpecification buildModel(GNElement rootElement)
  {
  	Logger.log("[ProcessSpecification.buildModel] Entering build model.");
  	if(rootElement == null)
  	{
  		return null;
  	}

      /** Unmarshals "version" attribute */
  	  super.setAttributeValue(version, rootElement.getAttribute("version"));
      
      /** Unmarshals "name" attribute */
  	  super.setAttributeValue(name, rootElement.getAttribute("name"));

      /** Unmarshals "uuid" attribute */
  	  super.setAttributeValue(uuid,rootElement.getAttribute("uuid"));

  	
    /** Unmarshals a list of "<<_tagName_>>" elements back to Documentation objects. */
    Iterator it1 = rootElement.getChildren(Documentation._tagName).iterator();
    while (it1.hasNext())
    {
    	Documentation doc = new Documentation();
      addDocumentation((doc.buildModel((GNElement)it1.next())));
    }
    /** Unmarshals a list of "<<_tagName_>>" elements back to SubstitutionSet objects. */
    Iterator it2 = rootElement.getChildren(SubstitutionSet._tagName).iterator();
    while (it2.hasNext())
    {
    	SubstitutionSet subSet = new SubstitutionSet();
     addSubstitutionSet(subSet.buildModel(
                                                       (GNElement)it2.next()));
    }
    /** Unmarshals a list of "<<_tagName_>>" elements back to Include objects. */
    Iterator it3 = rootElement.getChildren(Include._tagName).iterator();
    while (it3.hasNext())
    {
    	Include inc = new Include();
      addInclude(inc.buildModel(
                                               (GNElement)it3.next()));
    }
    
    /** Unmarshals a list of "<<_tagName_>>" elements back to BusinessDocument objects. */
    Iterator it4 = rootElement.getChildren(BusinessDocument._tagName).iterator();
    while (it4.hasNext())
    {
    	BusinessDocument bzDoc = new BusinessDocument();
      addBusinessDocument(bzDoc.buildModel(
                                                        (GNElement)it4.next()));
    }
    
    /** Unmarshals a list of "<<_tagName_>>" elements back to ProcessSpecification objects. */
    Iterator it5 = rootElement.getChildren(ProcessSpecification._tagName).iterator();
    while (it5.hasNext())
    {
    	ProcessSpecification ps = new ProcessSpecification();
      addProcessSpecification(ps.buildModel(
                                                            (GNElement)it5.next()));
    }
    
    /** Unmarshals a list of "<<_tagName_>>" elements back to Package objects. */
    Iterator it6 = rootElement.getChildren(Package._tagName).iterator();
    while (it6.hasNext())
    {
    	Package p = new Package();
      addPackage(p.buildModel(
                                               (GNElement)it6.next()));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to BinaryCollaboration objects. */
    Iterator it7 = rootElement.getChildren(BinaryCollaboration._tagName).iterator();
    while (it7.hasNext())
    {
    	BinaryCollaboration binCol = new BinaryCollaboration();
      addBinaryCollaboration(binCol.buildModel(
                                                           (GNElement)it7.next()));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to BusinessTransaction objects. */
    Iterator it8 = rootElement.getChildren(BusinessTransaction._tagName).iterator();
    while (it8.hasNext())
    {
    	BusinessTransaction bzTrans = new BusinessTransaction();
      addBusinessTransaction(bzTrans.buildModel(
                                                           (GNElement)it8.next()));
    }

    /** Unmarshals a list of "<<_tagName_>>" elements back to MultiPartyCollaboration objects. */
    Iterator it9 = rootElement.getChildren(MultiPartyCollaboration._tagName).iterator();
    while (it9.hasNext())
    {
    	MultiPartyCollaboration multiPC = new MultiPartyCollaboration();
      addMultiPartyCollaboration(multiPC.buildModel(
                                                               (GNElement)it9.next()));
    }
    
  	return this;
  }
  
  /**
   * TWX: Marshals this object to an element.
   */
  public GNElement buildElement()
  {
  	GNElement elem = GNXMLDocumentUtility.newElement(get_TagName());

    /** Marshals "version" attribute */
  	addAttributeToElement(elem, this._ATTR_DEFAULT_REQUIRED, version);

    /** Marshals "name" attribute */
  	addAttributeToElement(elem, this._ATTR_DEFAULT_REQUIRED, name);

    /** Marshals "uuid" attribute */
  	addAttributeToElement(elem, this._ATTR_DEFAULT_REQUIRED, uuid);

    /** Marshals a list of Documentation objects to elements */
    Iterator it1 = _objDocumentation.iterator();
    while (it1.hasNext())
    {
      Documentation obj = (Documentation)it1.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of SubstitutionSet objects to elements */
    Iterator it2 = _objSubstitutionSet.iterator();
    while (it2.hasNext())
    {
      SubstitutionSet obj = (SubstitutionSet)it2.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of Include objects to elements */
    Iterator it3 = _objInclude.iterator();
    while (it3.hasNext())
    {
      Include obj = (Include)it3.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of BusinessDocument objects to elements */
    Iterator it4 = _objBusinessDocument.iterator();
    while (it4.hasNext())
    {
      BusinessDocument obj = (BusinessDocument)it4.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of ProcessSpecification objects to elements */
    Iterator it5 = _objProcessSpecification.iterator();
    while (it5.hasNext())
    {
      ProcessSpecification obj = (ProcessSpecification)it5.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of Package objects to elements */
    Iterator it6 = _objPackage.iterator();
    while (it6.hasNext())
    {
      Package obj = (Package)it6.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of BinaryCollaboration objects to elements */
    Iterator it7 = _objBinaryCollaboration.iterator();
    while (it7.hasNext())
    {
      BinaryCollaboration obj = (BinaryCollaboration)it7.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of BusinessTransaction objects to elements */
    Iterator it8 = _objBusinessTransaction.iterator();
    while (it8.hasNext())
    {
      BusinessTransaction obj = (BusinessTransaction)it8.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }

    /** Marshals a list of MultiPartyCollaboration objects to elements */
    Iterator it9 = _objMultiPartyCollaboration.iterator();
    while (it9.hasNext())
    {
      MultiPartyCollaboration obj = (MultiPartyCollaboration)it9.next();
      if (obj != null)
        elem.addElement(obj.buildElement());
    }
    return elem;
  }
  
}
