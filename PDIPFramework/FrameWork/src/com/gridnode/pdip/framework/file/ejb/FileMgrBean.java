/* Generated by Together */

package com.gridnode.pdip.framework.file.ejb;

import java.io.*;
import java.rmi.RemoteException;
import java.util.zip.GZIPOutputStream;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;

import org.apache.webdav.lib.WebdavResource;

import com.gridnode.pdip.framework.exceptions.FileAccessException;
import com.gridnode.pdip.framework.file.access.BlockFileDescriptor;
import com.gridnode.pdip.framework.file.access.MultiFileBlock;
import com.gridnode.pdip.framework.file.access.Util;

/**
 * @ejbHome <{com.gridnode.pdip.framework.com.gridnode.pdip.framework.filemgr.manager.FileMgrHome}>
 * @ejbRemote <{com.gridnode.pdip.framework.com.gridnode.pdip.framework.filemgr.manager.FileMgr}>
 * @ejbStateful
 * @ejbTransactionAttribute Required
 */
public class FileMgrBean implements SessionBean {
  /**
	 * Serial Version UID
	 */
	private static final long serialVersionUID = 444916997726096982L;
		private SessionContext ctx;

    public void setSessionContext(SessionContext context) throws RemoteException, EJBException {
        ctx = context;
    }

    public void ejbActivate() throws RemoteException, EJBException {
    }

    public void ejbPassivate() throws RemoteException, EJBException {
    }

    public void ejbRemove() throws RemoteException, EJBException {
    }

    public void ejbCreate() throws CreateException, EJBException, RemoteException {
            // Write your code here
        }

  /**
   * creates a new folder in a webdav server
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param newPath The path relative to the domain for the new folder
   *
   * @return The complete path of the folder created or null if not created
   *
   * @ejbTransactionAttribute Required
   */
  public String createFolder(String domain, String newPath){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    String initialPath = webdavRes.getPath();
    String path = Util.createHigherLevelFolders(webdavRes, newPath);
    System.out.println("!!!folder path : "+path);
    try {
      int fileIndex = newPath.lastIndexOf("/");
      if (fileIndex > 0) {
        if (path.equals(initialPath+newPath.substring(0,fileIndex))) {
          webdavRes.setPath(path+newPath.substring(fileIndex));
          if (webdavRes.mkcolMethod())
            return path+newPath.substring(fileIndex);
        }
        return path;
      } else {
        webdavRes.setPath(webdavRes.getPath()+newPath);
        if (!webdavRes.mkcolMethod())
          return path;
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    System.out.println("!!!folder return path : "+webdavRes.getPath());
    return webdavRes.getPath();
  }

  /**
   * creates a new file in a webdav server
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param newPath The path relative to the domain for the new file
   *
   * @param in The contents of the new file or null if the new file is empty
   *
   * @param overwrite If there is an existing file, it will be overwritten if
   * this parameter is set to true
   *
   * @return The complete path of the file created or null if not created
   *
   * @ejbTransactionAttribute Required
   */
  public String createFile(String domain, String newPath, byte[] in, boolean overwrite)
          throws IOException
  {
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;

    String initialPath = webdavRes.getPath();
    String path = Util.createHigherLevelFolders(webdavRes, newPath);
    System.out.println("!!!file path : " + path);
    try
    {
      int fileIndex = newPath.lastIndexOf("/");
      if (fileIndex > 0)
      {
        if (path.equals(initialPath+newPath.substring(0,fileIndex)))
        {
          webdavRes.setPath(path+newPath.substring(fileIndex));
          System.out.println("!!!Set path is " + webdavRes.getPath());
          if (!webdavRes.exists() || overwrite)
          {
            if (!Util.write(webdavRes, in))
              return path;
          }
          else
            throw new IOException("File already exist: " + webdavRes.getPath());
        }
        else
          return path;
      }
      else
      {
        webdavRes.setPath(webdavRes.getPath()+newPath);
        if (!webdavRes.exists() || overwrite)
        {
          if (!Util.write(webdavRes, in))
            return path;
        }
        else
          throw new IOException("File already exist: " + webdavRes.getPath());
      }
    }
    catch (IOException ioe)
    {
      throw ioe;
    }
    catch (Exception ex)
    {
      ex.printStackTrace();
    }
    System.out.println("!!!file return path : " + webdavRes.getPath());
    return webdavRes.getPath();
  }

  /**
   * moves a folder from one location in a webdav server to another
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param src The path relative to the domain for the source folder
   *
   * @param des The path relative to the domain for the destination folder
   *
   * @param overwrite If there is an existing folder, it will be overwritten if
   * this parameter is set to true
   *
   * @return The complete path of the folder created or null if not created
   *
   * @ejbTransactionAttribute Required
   */
  public String moveFolder(String domain, String src, String des, boolean overwrite){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    try {
      String path = webdavRes.getPath();
      webdavRes.setOverwrite(overwrite);
      webdavRes.setPath(path+src);
      if (webdavRes.isCollection() && webdavRes.exists())
        if (webdavRes.moveMethod(path+des))
          return path+des;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * moves a file from one location in a webdav server to another
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param src The path relative to the domain for the source file
   *
   * @param des The path relative to the domain for the destination file
   *
   * @param overwrite If there is an existing file, it will be overwritten if
   * this parameter is set to true
   *
   * @return The complete path of the file created or null if not created
   *
   * @ejbTransactionAttribute Required
   */
  public String moveFile(String domain, String src, String des, boolean overwrite){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    try {
      String path = webdavRes.getPath();
      webdavRes.setOverwrite(overwrite);
      webdavRes.setPath(path+src);
      if (!webdavRes.isCollection() && webdavRes.exists())
        if (webdavRes.moveMethod(path+des))
          return path+des;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * copies a folder from one location in a webdav server to another
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param src The path relative to the domain for the source folder
   *
   * @param des The path relative to the domain for the destination folder
   *
   * @param overwrite If there is an existing folder, it will be overwritten if
   * this parameter is set to true
   *
   * @return The complete path of the folder created or null if not created
   *
   * @ejbTransactionAttribute Required
   */
  public String copyFolder(String domain, String src, String des, boolean overwrite){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    try {
      String path = webdavRes.getPath();
      webdavRes.setOverwrite(overwrite);
      webdavRes.setPath(path+src);
      if (webdavRes.isCollection() && webdavRes.exists())
        if (webdavRes.copyMethod(path+des))
          return path+des;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * copies a file from one location in a webdav server to another
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param src The path relative to the domain for the source file
   *
   * @param des The path relative to the domain for the destination file
   *
   * @param overwrite If there is an existing file, it will be overwritten if
   * this parameter is set to true
   *
   * @return The complete path of the file created or null if not created
   *
   * @ejbTransactionAttribute Required
   */
  public String copyFile(String domain, String src, String des, boolean overwrite){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    try {
      String path = webdavRes.getPath();
      webdavRes.setOverwrite(overwrite);
      webdavRes.setPath(path+src);
      System.out.println("!!!Source path is "+webdavRes.getPath());
      System.out.println("!!!Source is a " + (webdavRes.isCollection()? "dir" : "file"));
      System.out.println("!!!Source " + (webdavRes.exists()? "exists" : "does not exist"));
      if (!webdavRes.isCollection() && webdavRes.exists())
        if (webdavRes.copyMethod(path+des))
          return path+des;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * creates a new folder in a webdav server
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param delPath The path relative to the domain for the folder to be deleted
   *
   * @return The complete path of the folder deleted or null if not deleted
   *
   * @ejbTransactionAttribute Required
   */
  public String deleteFolder(String domain, String delPath){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    try {
      String path = webdavRes.getPath();
      if (webdavRes.isCollection() && webdavRes.exists())
        if (webdavRes.deleteMethod(path+delPath))
          return path+delPath;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * creates a new file in a webdav server
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param delPath The path relative to the domain for the file to be deleted
   *
   * @return The complete path of the file deleted or null if not deleted
   *
   * @ejbTransactionAttribute Required
   */
  public String deleteFile(String domain, String delPath){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    try {
      String path = webdavRes.getPath();
      webdavRes.setPath(path+delPath);
      if (!webdavRes.isCollection() && webdavRes.exists())
        if (webdavRes.deleteMethod())
          return path+delPath;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * retrieves the content of an existing file
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param path The path relative to the domain for the file
   *
   * @return The contents of the file
   *
   * @ejbTransactionAttribute Required
   */
  public byte[] getFile(String domain, String path){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    try {
      webdavRes.setPath(webdavRes.getPath()+path);
      if (!webdavRes.isCollection() && webdavRes.exists()) {
        File file=Util.createCache();
        if (webdavRes.getMethod(file)) {
          byte[] outBytes = new byte[(int)webdavRes.getGetContentLength()];
          FileInputStream in = new FileInputStream(file);
          in.read(outBytes);
          for (int i=0; i<(int)file.length(); i++)
            System.out.print((char)outBytes[i]);

          return outBytes;
        }
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * retrieves the content of an existing file
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param path The path relative to the domain for the file
   *
   * @param buffer One block of the contents of the file
   *
   * @param block The block of content to get
   *
   * @return
   *
   * @ejbTransactionAttribute Required
   */
  public byte[] readFromFile(String domain, String path, int block, int len){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    byte[] buffer = new byte[len];
    try {
      webdavRes.setPath(webdavRes.getPath()+path);
      if (!webdavRes.isCollection() && webdavRes.exists()) {
        File file=Util.createCache();
        if (webdavRes.getMethod(file)) {
          RandomAccessFile in = new RandomAccessFile(file, "r");
          in.seek((block-1)*len);
          int result=-1;
          if (in.getFilePointer() < in.length()) {
            result = in.read(buffer);
            ByteArrayOutputStream out = new ByteArrayOutputStream(result);
            out.write(buffer, 0, result);
            in.close();
            return out.toByteArray();
          }
        }
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * retrieves the content of an existing file
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param path The path relative to the domain for the file
   *
   * @param offset Offset from the start of the file.
   *
   * @param len the length of the file content to retrieve.
   *
   * @return
   *
   * @ejbTransactionAttribute Required
   */
  //Modified by Goh Kan Mun (21/3/2003): to retrieve byte array from file based on
  //offset instead of in block.
  public byte[] readByteFromFile(String domain, String path, long offset, int len)
          throws EOFException, FileAccessException
  {
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      throw new FileAccessException("webdav resource is not defined");
    byte[] buffer = new byte[len];
    try
    {
      webdavRes.setPath(webdavRes.getPath() + path);
      if (!webdavRes.isCollection() && webdavRes.exists())
      {
        File file = Util.createCache();
        if (webdavRes.getMethod(file))
        {
          RandomAccessFile in = new RandomAccessFile(file, "r");
          in.seek(len);
          int totalBytesRead = 0;
          ByteArrayOutputStream out = new ByteArrayOutputStream();
          while (totalBytesRead < len && in.getFilePointer() < in.length())
          {
            int result = in.read(buffer, 0, (len - totalBytesRead));
            if (result < 0)
            {
              if (totalBytesRead == 0)
                throw new EOFException("End of file reached.");
              else
                break;
            }
            out.write(buffer, 0, result);
            totalBytesRead += result;
          }
          in.close();
          file.delete();
          out.close();
          return out.toByteArray();
        }
        else
          throw new FileAccessException("Unable to retrieve file to local");
      }
      else
        throw new FileAccessException("Path does not exist or is not a File");
    }
    catch (EOFException eofe)
    {
      throw eofe;
    }
    catch (FileAccessException fae)
    {
      throw fae;
    }
    catch (Exception ex)
    {
      throw new FileAccessException(ex);
    }
  }

  /**
   * @ejbTransactionAttribute Required
   */
  public byte[] readFromFileZipped(String domain, String path,  long offset, int len){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    //byte[] buffer = new byte[len];
    try {
      webdavRes.setPath(webdavRes.getPath()+path);
      if (!webdavRes.isCollection() && webdavRes.exists()) {
        File file=Util.createCache();
        if (webdavRes.getMethod(file)) {
          RandomAccessFile in = new RandomAccessFile(file, "r");
          byte[] tmpBuf = new byte[len];
          int bufSize=0;
          int totalBufSize = 0;
          //int result=0;
          int readResult=0;
          ByteArrayOutputStream bOut = new ByteArrayOutputStream(len);
          GZIPOutputStream zOut = new GZIPOutputStream(bOut, len);
          in.seek(offset);
          while (totalBufSize < len && in.getFilePointer() < in.length()) {
            readResult = in.read(tmpBuf);

            if (readResult != -1) {
              zOut.write(tmpBuf);
              bufSize = bOut.size();
              totalBufSize += readResult;
              System.out.println("!!!bufSize = "+bufSize);
              System.out.println("!!!totalBufSize = "+totalBufSize);
            } else {
              break;
            }
          }
          zOut.close();
          in.close();
          return bOut.toByteArray();
        }
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  /**
   * @ejbTransactionAttribute Required
   */
  public MultiFileBlock readFromStreamZipped(String domain, String[] paths, long offset, int len){
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return null;
    //byte[] buffer = new byte[len];
    try {
      String initialPath = webdavRes.getPath();
      File file=Util.createCache();

      // AMH: modified to use getStartFilePath
      //int startFileIndex = Util.getStartFileIndex(webdavRes, paths, offset);
      int startFileIndex = Util.getStartFilePath(webdavRes, paths, offset);

      long startFileOffset = Util.getStartFileOffset(webdavRes, paths, offset);
      int i = startFileIndex;
      long j = startFileOffset;
      //int bufSize=0;
      int totalBufSize=0;
      int readResult=0;
      ByteArrayOutputStream bOut = new ByteArrayOutputStream(len);
      GZIPOutputStream zOut = new GZIPOutputStream(bOut, len);
      MultiFileBlock block = new MultiFileBlock();
      while (totalBufSize < len && i < paths.length) {
        webdavRes.setPath(initialPath+paths[i]);
        if (!webdavRes.isCollection() && webdavRes.exists()) {
          if (webdavRes.getMethod(file)) {
            RandomAccessFile in = new RandomAccessFile(file, "r");
            byte[] tmpBuf = new byte[len-totalBufSize];
            in.seek(j);
            while (totalBufSize < len && in.getFilePointer() < in.length()) {
              readResult = in.read(tmpBuf);
              if (readResult != -1) {
                zOut.write(tmpBuf, 0, readResult);
                //bufSize = bOut.size();
                totalBufSize += readResult;
//                System.out.println("!!!bufSize = "+bufSize);
//                System.out.println("!!!totalBufSize = "+totalBufSize);
              } else {
                break;
              }
            }
//            totalBufSize += bufSize;
            BlockFileDescriptor des = new BlockFileDescriptor(domain, paths[i], in.length());
            block.addBlockFileDescriptor(des);
            in.close();
            i++;
            j=0;
          } else {
            return null;
          }
        } else {
          return null;
        }
      }
      zOut.close();
      block.setBlockData(bOut.toByteArray());
      return block;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return null;
  }

  // Added in by Kan Mun. 08/01/2003.
  /**
   * To check whether a file exist in the remote server.
   */
  public boolean exist(String domain, String path)
  {
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return false;
    try
    {
      String webpath = webdavRes.getPath();
      webdavRes.setPath(webpath + path);
      System.out.println("!!!Source path is " + webdavRes.getPath());
      return (webdavRes.exists());
    }
    catch (Exception ex)
    {
      ex.printStackTrace();
    }
    return false;
  }

  // Added in by Kan Mun. 08/01/2003.
  /**
   * To retrieve the length of a file in the remote server.
   */
  public long length(String domain, String path)
  {
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return 0l;
    try
    {
      String webpath = webdavRes.getPath();
      webdavRes.setPath(webpath + path);
      System.out.println("!!!Source path is " + webdavRes.getPath());
      if (webdavRes.exists())
        return (webdavRes.getGetContentLength());
      else
        return 0l;
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return 0l;
  }

  /**
   * creates a new empty file in a webdav server
   *
   * @param domain The namespace used to identify the application domain (1st
   * level directory) to use
   *
   * @param newPath The path relative to the domain for the new file
   *
   * @param in The contents of the new file or null if the new file is empty
   *
   * @param overwrite If there is an existing file, it will be overwritten if
   * this parameter is set to true
   *
   * @return The complete path of the file created or null if not created
   *
   * @ejbTransactionAttribute Required
   */
  public boolean createNewFile(String domain, String newPath)
  {
    WebdavResource webdavRes = Util.initWebdavResource(domain);
    if (webdavRes == null)
      return false;

    //String initialPath = webdavRes.getPath();
    //String path = 
    Util.createHigherLevelFolders(webdavRes, newPath);
    try
    {
      webdavRes.setPath(webdavRes.getPath() + newPath);
      return webdavRes.putMethod("");
    }
    catch (Exception ex)
    {
      ex.printStackTrace();
    }
    return false;
  }


//    public String setFile(String domain, String path, boolean overwrite){
//      return moveFile(domain, oldPath, newPath, false);
//    }

/*    public IPdipTransfer openTransfer(String domain, String path, int op) {
    IPdipTransfer remote=null;
    try {
      IPdipTransferHome home=(IPdipTransferHome)ServiceLookup.getInstance(
        ServiceLookup.CLIENT_CONTEXT).getHome(IPdipTransferHome.class);
      remote = home.create(domain, path, op);
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
    return remote;
  }

  public void closeTransfer(IPdipTransfer remote) {
    try {
      remote.remove();
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
  }
*/
}
